// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: kira/spending/tx.proto

package types

import (
	context "context"
	fmt "fmt"
	github_com_cosmos_cosmos_sdk_types "github.com/cosmos/cosmos-sdk/types"
	_ "github.com/gogo/protobuf/gogoproto"
	grpc1 "github.com/gogo/protobuf/grpc"
	proto "github.com/gogo/protobuf/proto"
	github_com_gogo_protobuf_types "github.com/gogo/protobuf/types"
	_ "github.com/golang/protobuf/ptypes/timestamp"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
	io "io"
	math "math"
	math_bits "math/bits"
	time "time"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf
var _ = time.Kitchen

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

type MsgCreateSpendingPool struct {
	Name string `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	// claim-start & claim-end - defines the exact time period (Unix timestamps) between which tokens can be claimed from the pool, allowing for a precise funds distribution.
	ClaimStart time.Time `protobuf:"bytes,2,opt,name=claim_start,json=claimStart,proto3,stdtime" json:"claim_start"`
	ClaimEnd   time.Time `protobuf:"bytes,3,opt,name=claim_end,json=claimEnd,proto3,stdtime" json:"claim_end"`
	// claim-expire - time period after which ability of beneficiary to claim tokens expires. If the date of the last claim is longer than claim-expire than account is removed from claims list.
	Expire uint64 `protobuf:"varint,4,opt,name=expire,proto3" json:"expire,omitempty"`
	Token  string `protobuf:"bytes,5,opt,name=token,proto3" json:"token,omitempty"`
	// rate of distribution in the smallest token denomination per 1 second (this value can be a float number, smaller than actual denomination)
	Rate github_com_cosmos_cosmos_sdk_types.Dec `protobuf:"bytes,6,opt,name=rate,proto3,customtype=github.com/cosmos/cosmos-sdk/types.Dec" json:"rate" yaml:"rate"`
	// pool specific % of owner accounts that must vote YES or NO for any of the pool proposals to be valid.
	VoteQuorum uint64 `protobuf:"varint,7,opt,name=vote_quorum,json=voteQuorum,proto3" json:"vote_quorum,omitempty"`
	// period of time in seconds that any of the pool proposals must last before passing or being rejected
	VotePeriod uint64 `protobuf:"varint,8,opt,name=vote_period,json=votePeriod,proto3" json:"vote_period,omitempty"`
	// period of time that must pass before any of the pool proposal is enacted
	VoteEnactment uint64 `protobuf:"varint,9,opt,name=vote_enactment,json=voteEnactment,proto3" json:"vote_enactment,omitempty"`
	// defines a list of accounts/roles controlling the spending pool via “governance-like” proposals
	Owners *PermInfo `protobuf:"bytes,10,opt,name=owners,proto3" json:"owners,omitempty"`
	// defines set of accounts/roles to which funds can be distributed
	Beneficiaries *PermInfo `protobuf:"bytes,11,opt,name=beneficiaries,proto3" json:"beneficiaries,omitempty"`
	Sender        string    `protobuf:"bytes,12,opt,name=sender,proto3" json:"sender,omitempty"`
}

func (m *MsgCreateSpendingPool) Reset()         { *m = MsgCreateSpendingPool{} }
func (m *MsgCreateSpendingPool) String() string { return proto.CompactTextString(m) }
func (*MsgCreateSpendingPool) ProtoMessage()    {}
func (*MsgCreateSpendingPool) Descriptor() ([]byte, []int) {
	return fileDescriptor_edfb840607cf4f3d, []int{0}
}
func (m *MsgCreateSpendingPool) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgCreateSpendingPool) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgCreateSpendingPool.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgCreateSpendingPool) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgCreateSpendingPool.Merge(m, src)
}
func (m *MsgCreateSpendingPool) XXX_Size() int {
	return m.Size()
}
func (m *MsgCreateSpendingPool) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgCreateSpendingPool.DiscardUnknown(m)
}

var xxx_messageInfo_MsgCreateSpendingPool proto.InternalMessageInfo

func (m *MsgCreateSpendingPool) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *MsgCreateSpendingPool) GetClaimStart() time.Time {
	if m != nil {
		return m.ClaimStart
	}
	return time.Time{}
}

func (m *MsgCreateSpendingPool) GetClaimEnd() time.Time {
	if m != nil {
		return m.ClaimEnd
	}
	return time.Time{}
}

func (m *MsgCreateSpendingPool) GetExpire() uint64 {
	if m != nil {
		return m.Expire
	}
	return 0
}

func (m *MsgCreateSpendingPool) GetToken() string {
	if m != nil {
		return m.Token
	}
	return ""
}

func (m *MsgCreateSpendingPool) GetVoteQuorum() uint64 {
	if m != nil {
		return m.VoteQuorum
	}
	return 0
}

func (m *MsgCreateSpendingPool) GetVotePeriod() uint64 {
	if m != nil {
		return m.VotePeriod
	}
	return 0
}

func (m *MsgCreateSpendingPool) GetVoteEnactment() uint64 {
	if m != nil {
		return m.VoteEnactment
	}
	return 0
}

func (m *MsgCreateSpendingPool) GetOwners() *PermInfo {
	if m != nil {
		return m.Owners
	}
	return nil
}

func (m *MsgCreateSpendingPool) GetBeneficiaries() *PermInfo {
	if m != nil {
		return m.Beneficiaries
	}
	return nil
}

func (m *MsgCreateSpendingPool) GetSender() string {
	if m != nil {
		return m.Sender
	}
	return ""
}

type MsgCreateSpendingPoolResponse struct {
}

func (m *MsgCreateSpendingPoolResponse) Reset()         { *m = MsgCreateSpendingPoolResponse{} }
func (m *MsgCreateSpendingPoolResponse) String() string { return proto.CompactTextString(m) }
func (*MsgCreateSpendingPoolResponse) ProtoMessage()    {}
func (*MsgCreateSpendingPoolResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_edfb840607cf4f3d, []int{1}
}
func (m *MsgCreateSpendingPoolResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgCreateSpendingPoolResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgCreateSpendingPoolResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgCreateSpendingPoolResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgCreateSpendingPoolResponse.Merge(m, src)
}
func (m *MsgCreateSpendingPoolResponse) XXX_Size() int {
	return m.Size()
}
func (m *MsgCreateSpendingPoolResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgCreateSpendingPoolResponse.DiscardUnknown(m)
}

var xxx_messageInfo_MsgCreateSpendingPoolResponse proto.InternalMessageInfo

type MsgDepositSpendingPool struct {
	Sender   string                                    `protobuf:"bytes,1,opt,name=sender,proto3" json:"sender,omitempty"`
	PoolName string                                    `protobuf:"bytes,2,opt,name=pool_name,json=poolName,proto3" json:"pool_name,omitempty"`
	Amount   []github_com_cosmos_cosmos_sdk_types.Coin `protobuf:"bytes,3,rep,name=amount,proto3,customtype=github.com/cosmos/cosmos-sdk/types.Coin" json:"amount"`
}

func (m *MsgDepositSpendingPool) Reset()         { *m = MsgDepositSpendingPool{} }
func (m *MsgDepositSpendingPool) String() string { return proto.CompactTextString(m) }
func (*MsgDepositSpendingPool) ProtoMessage()    {}
func (*MsgDepositSpendingPool) Descriptor() ([]byte, []int) {
	return fileDescriptor_edfb840607cf4f3d, []int{2}
}
func (m *MsgDepositSpendingPool) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgDepositSpendingPool) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgDepositSpendingPool.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgDepositSpendingPool) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgDepositSpendingPool.Merge(m, src)
}
func (m *MsgDepositSpendingPool) XXX_Size() int {
	return m.Size()
}
func (m *MsgDepositSpendingPool) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgDepositSpendingPool.DiscardUnknown(m)
}

var xxx_messageInfo_MsgDepositSpendingPool proto.InternalMessageInfo

func (m *MsgDepositSpendingPool) GetSender() string {
	if m != nil {
		return m.Sender
	}
	return ""
}

func (m *MsgDepositSpendingPool) GetPoolName() string {
	if m != nil {
		return m.PoolName
	}
	return ""
}

type MsgDepositSpendingPoolResponse struct {
}

func (m *MsgDepositSpendingPoolResponse) Reset()         { *m = MsgDepositSpendingPoolResponse{} }
func (m *MsgDepositSpendingPoolResponse) String() string { return proto.CompactTextString(m) }
func (*MsgDepositSpendingPoolResponse) ProtoMessage()    {}
func (*MsgDepositSpendingPoolResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_edfb840607cf4f3d, []int{3}
}
func (m *MsgDepositSpendingPoolResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgDepositSpendingPoolResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgDepositSpendingPoolResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgDepositSpendingPoolResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgDepositSpendingPoolResponse.Merge(m, src)
}
func (m *MsgDepositSpendingPoolResponse) XXX_Size() int {
	return m.Size()
}
func (m *MsgDepositSpendingPoolResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgDepositSpendingPoolResponse.DiscardUnknown(m)
}

var xxx_messageInfo_MsgDepositSpendingPoolResponse proto.InternalMessageInfo

type MsgRegisterSpendingPoolBeneficiary struct {
	Sender      string `protobuf:"bytes,1,opt,name=sender,proto3" json:"sender,omitempty"`
	PoolName    string `protobuf:"bytes,2,opt,name=pool_name,json=poolName,proto3" json:"pool_name,omitempty"`
	Beneficiary string `protobuf:"bytes,3,opt,name=beneficiary,proto3" json:"beneficiary,omitempty"`
}

func (m *MsgRegisterSpendingPoolBeneficiary) Reset()         { *m = MsgRegisterSpendingPoolBeneficiary{} }
func (m *MsgRegisterSpendingPoolBeneficiary) String() string { return proto.CompactTextString(m) }
func (*MsgRegisterSpendingPoolBeneficiary) ProtoMessage()    {}
func (*MsgRegisterSpendingPoolBeneficiary) Descriptor() ([]byte, []int) {
	return fileDescriptor_edfb840607cf4f3d, []int{4}
}
func (m *MsgRegisterSpendingPoolBeneficiary) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgRegisterSpendingPoolBeneficiary) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgRegisterSpendingPoolBeneficiary.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgRegisterSpendingPoolBeneficiary) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgRegisterSpendingPoolBeneficiary.Merge(m, src)
}
func (m *MsgRegisterSpendingPoolBeneficiary) XXX_Size() int {
	return m.Size()
}
func (m *MsgRegisterSpendingPoolBeneficiary) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgRegisterSpendingPoolBeneficiary.DiscardUnknown(m)
}

var xxx_messageInfo_MsgRegisterSpendingPoolBeneficiary proto.InternalMessageInfo

func (m *MsgRegisterSpendingPoolBeneficiary) GetSender() string {
	if m != nil {
		return m.Sender
	}
	return ""
}

func (m *MsgRegisterSpendingPoolBeneficiary) GetPoolName() string {
	if m != nil {
		return m.PoolName
	}
	return ""
}

func (m *MsgRegisterSpendingPoolBeneficiary) GetBeneficiary() string {
	if m != nil {
		return m.Beneficiary
	}
	return ""
}

type MsgRegisterSpendingPoolBeneficiaryResponse struct {
}

func (m *MsgRegisterSpendingPoolBeneficiaryResponse) Reset() {
	*m = MsgRegisterSpendingPoolBeneficiaryResponse{}
}
func (m *MsgRegisterSpendingPoolBeneficiaryResponse) String() string {
	return proto.CompactTextString(m)
}
func (*MsgRegisterSpendingPoolBeneficiaryResponse) ProtoMessage() {}
func (*MsgRegisterSpendingPoolBeneficiaryResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_edfb840607cf4f3d, []int{5}
}
func (m *MsgRegisterSpendingPoolBeneficiaryResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgRegisterSpendingPoolBeneficiaryResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgRegisterSpendingPoolBeneficiaryResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgRegisterSpendingPoolBeneficiaryResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgRegisterSpendingPoolBeneficiaryResponse.Merge(m, src)
}
func (m *MsgRegisterSpendingPoolBeneficiaryResponse) XXX_Size() int {
	return m.Size()
}
func (m *MsgRegisterSpendingPoolBeneficiaryResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgRegisterSpendingPoolBeneficiaryResponse.DiscardUnknown(m)
}

var xxx_messageInfo_MsgRegisterSpendingPoolBeneficiaryResponse proto.InternalMessageInfo

type MsgClaimSpendingPool struct {
	Sender   string `protobuf:"bytes,1,opt,name=sender,proto3" json:"sender,omitempty"`
	PoolName string `protobuf:"bytes,2,opt,name=pool_name,json=poolName,proto3" json:"pool_name,omitempty"`
}

func (m *MsgClaimSpendingPool) Reset()         { *m = MsgClaimSpendingPool{} }
func (m *MsgClaimSpendingPool) String() string { return proto.CompactTextString(m) }
func (*MsgClaimSpendingPool) ProtoMessage()    {}
func (*MsgClaimSpendingPool) Descriptor() ([]byte, []int) {
	return fileDescriptor_edfb840607cf4f3d, []int{6}
}
func (m *MsgClaimSpendingPool) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgClaimSpendingPool) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgClaimSpendingPool.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgClaimSpendingPool) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgClaimSpendingPool.Merge(m, src)
}
func (m *MsgClaimSpendingPool) XXX_Size() int {
	return m.Size()
}
func (m *MsgClaimSpendingPool) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgClaimSpendingPool.DiscardUnknown(m)
}

var xxx_messageInfo_MsgClaimSpendingPool proto.InternalMessageInfo

func (m *MsgClaimSpendingPool) GetSender() string {
	if m != nil {
		return m.Sender
	}
	return ""
}

func (m *MsgClaimSpendingPool) GetPoolName() string {
	if m != nil {
		return m.PoolName
	}
	return ""
}

type MsgClaimSpendingPoolResponse struct {
}

func (m *MsgClaimSpendingPoolResponse) Reset()         { *m = MsgClaimSpendingPoolResponse{} }
func (m *MsgClaimSpendingPoolResponse) String() string { return proto.CompactTextString(m) }
func (*MsgClaimSpendingPoolResponse) ProtoMessage()    {}
func (*MsgClaimSpendingPoolResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_edfb840607cf4f3d, []int{7}
}
func (m *MsgClaimSpendingPoolResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgClaimSpendingPoolResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgClaimSpendingPoolResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgClaimSpendingPoolResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgClaimSpendingPoolResponse.Merge(m, src)
}
func (m *MsgClaimSpendingPoolResponse) XXX_Size() int {
	return m.Size()
}
func (m *MsgClaimSpendingPoolResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgClaimSpendingPoolResponse.DiscardUnknown(m)
}

var xxx_messageInfo_MsgClaimSpendingPoolResponse proto.InternalMessageInfo

func init() {
	proto.RegisterType((*MsgCreateSpendingPool)(nil), "kira.spending.MsgCreateSpendingPool")
	proto.RegisterType((*MsgCreateSpendingPoolResponse)(nil), "kira.spending.MsgCreateSpendingPoolResponse")
	proto.RegisterType((*MsgDepositSpendingPool)(nil), "kira.spending.MsgDepositSpendingPool")
	proto.RegisterType((*MsgDepositSpendingPoolResponse)(nil), "kira.spending.MsgDepositSpendingPoolResponse")
	proto.RegisterType((*MsgRegisterSpendingPoolBeneficiary)(nil), "kira.spending.MsgRegisterSpendingPoolBeneficiary")
	proto.RegisterType((*MsgRegisterSpendingPoolBeneficiaryResponse)(nil), "kira.spending.MsgRegisterSpendingPoolBeneficiaryResponse")
	proto.RegisterType((*MsgClaimSpendingPool)(nil), "kira.spending.MsgClaimSpendingPool")
	proto.RegisterType((*MsgClaimSpendingPoolResponse)(nil), "kira.spending.MsgClaimSpendingPoolResponse")
}

func init() { proto.RegisterFile("kira/spending/tx.proto", fileDescriptor_edfb840607cf4f3d) }

var fileDescriptor_edfb840607cf4f3d = []byte{
	// 695 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xa4, 0x55, 0xc1, 0x6e, 0xd3, 0x40,
	0x10, 0x8d, 0x9b, 0x34, 0x24, 0x13, 0x8a, 0xc4, 0x52, 0x8a, 0x15, 0xc0, 0x8e, 0x0c, 0x85, 0xa8,
	0xb4, 0xb6, 0x28, 0x27, 0x90, 0x7a, 0x20, 0x6d, 0x85, 0x50, 0x15, 0xd4, 0xba, 0x9c, 0xb8, 0x54,
	0x4e, 0x32, 0x75, 0xad, 0xc4, 0xbb, 0x66, 0x77, 0x03, 0x8d, 0xf8, 0x08, 0x7a, 0xe2, 0x17, 0xf8,
	0x95, 0x1e, 0x7b, 0x41, 0x42, 0x1c, 0x0a, 0x6a, 0xff, 0x80, 0x2f, 0x40, 0xde, 0x38, 0x69, 0xd2,
	0x5a, 0x34, 0x85, 0x53, 0x3c, 0x6f, 0xdf, 0xbc, 0x99, 0xcc, 0xbc, 0xb5, 0x61, 0xae, 0x1d, 0x70,
	0xcf, 0x11, 0x11, 0xd2, 0x56, 0x40, 0x7d, 0x47, 0xee, 0xdb, 0x11, 0x67, 0x92, 0x91, 0x99, 0x18,
	0xb7, 0x07, 0x78, 0x79, 0xd6, 0x67, 0x3e, 0x53, 0x27, 0x4e, 0xfc, 0xd4, 0x27, 0x95, 0x4d, 0x9f,
	0x31, 0xbf, 0x83, 0x8e, 0x8a, 0x1a, 0xdd, 0x5d, 0x47, 0x06, 0x21, 0x0a, 0xe9, 0x85, 0x51, 0x42,
	0xd0, 0xc7, 0xd5, 0x23, 0xc6, 0x3a, 0xfd, 0x13, 0xeb, 0x6b, 0x0e, 0x6e, 0xd7, 0x85, 0xbf, 0xca,
	0xd1, 0x93, 0xb8, 0x9d, 0x10, 0x36, 0x19, 0xeb, 0x10, 0x02, 0x39, 0xea, 0x85, 0xa8, 0x6b, 0x15,
	0xad, 0x5a, 0x74, 0xd5, 0x33, 0x59, 0x87, 0x52, 0xb3, 0xe3, 0x05, 0xe1, 0x8e, 0x90, 0x1e, 0x97,
	0xfa, 0x54, 0x45, 0xab, 0x96, 0x96, 0xcb, 0x76, 0xbf, 0xbc, 0x3d, 0x28, 0x6f, 0xbf, 0x1d, 0x94,
	0xaf, 0x15, 0x0e, 0x8f, 0xcd, 0xcc, 0xc1, 0x4f, 0x53, 0x73, 0x41, 0x25, 0x6e, 0xc7, 0x79, 0xe4,
	0x25, 0x14, 0xfb, 0x32, 0x48, 0x5b, 0x7a, 0xf6, 0x0a, 0x22, 0x05, 0x95, 0xb6, 0x4e, 0x5b, 0x64,
	0x0e, 0xf2, 0xb8, 0x1f, 0x05, 0x1c, 0xf5, 0x5c, 0x45, 0xab, 0xe6, 0xdc, 0x24, 0x22, 0xb3, 0x30,
	0x2d, 0x59, 0x1b, 0xa9, 0x3e, 0xad, 0xda, 0xee, 0x07, 0x64, 0x0b, 0x72, 0xdc, 0x93, 0xa8, 0xe7,
	0x63, 0xb0, 0xb6, 0x12, 0xeb, 0xfd, 0x38, 0x36, 0x1f, 0xf9, 0x81, 0xdc, 0xeb, 0x36, 0xec, 0x26,
	0x0b, 0x9d, 0x26, 0x13, 0x21, 0x13, 0xc9, 0xcf, 0x92, 0x68, 0xb5, 0x1d, 0xd9, 0x8b, 0x50, 0xd8,
	0x6b, 0xd8, 0xfc, 0x7d, 0x6c, 0x96, 0x7a, 0x5e, 0xd8, 0x79, 0x61, 0xc5, 0x1a, 0x96, 0xab, 0xa4,
	0x88, 0x09, 0xa5, 0x0f, 0x4c, 0xe2, 0xce, 0xfb, 0x2e, 0xe3, 0xdd, 0x50, 0xbf, 0xa6, 0xba, 0x80,
	0x18, 0xda, 0x52, 0xc8, 0x90, 0x10, 0x21, 0x0f, 0x58, 0x4b, 0x2f, 0x9c, 0x11, 0x36, 0x15, 0x42,
	0xe6, 0xe1, 0x86, 0x22, 0x20, 0xf5, 0x9a, 0x32, 0x44, 0x2a, 0xf5, 0xa2, 0xe2, 0xcc, 0xc4, 0xe8,
	0xfa, 0x00, 0x24, 0x0e, 0xe4, 0xd9, 0x47, 0x8a, 0x5c, 0xe8, 0xa0, 0x26, 0x75, 0xc7, 0x1e, 0xb3,
	0x84, 0xbd, 0x89, 0x3c, 0x7c, 0x4d, 0x77, 0x99, 0x9b, 0xd0, 0xc8, 0x0a, 0xcc, 0x34, 0x90, 0xe2,
	0x6e, 0xd0, 0x0c, 0x3c, 0x1e, 0xa0, 0xd0, 0x4b, 0x7f, 0xcf, 0x1b, 0x67, 0xc7, 0x93, 0x15, 0x48,
	0x5b, 0xc8, 0xf5, 0xeb, 0x6a, 0x84, 0x49, 0x64, 0x99, 0x70, 0x3f, 0xd5, 0x28, 0x2e, 0x8a, 0x88,
	0x51, 0x81, 0xd6, 0x17, 0x0d, 0xe6, 0xea, 0xc2, 0x5f, 0xc3, 0x88, 0x89, 0x40, 0x8e, 0x79, 0xe9,
	0x4c, 0x53, 0x1b, 0xd5, 0x24, 0x77, 0xa1, 0x18, 0x7b, 0x71, 0x47, 0x19, 0x6d, 0x4a, 0x1d, 0x15,
	0x62, 0xe0, 0x4d, 0x6c, 0xb6, 0x57, 0x90, 0xf7, 0x42, 0xd6, 0xa5, 0x52, 0xcf, 0x56, 0xb2, 0xd5,
	0x62, 0xcd, 0x49, 0xd6, 0xf6, 0x78, 0x82, 0xb5, 0xad, 0xb2, 0x80, 0xba, 0x49, 0xba, 0x55, 0x01,
	0x23, 0xbd, 0xaf, 0x61, 0xeb, 0x9f, 0xc0, 0xaa, 0x0b, 0xdf, 0x45, 0x3f, 0x10, 0x12, 0xf9, 0x28,
	0xa5, 0x36, 0x9c, 0x4d, 0xef, 0xdf, 0xfe, 0x45, 0x05, 0x4a, 0x67, 0xf3, 0xed, 0x29, 0xb7, 0x17,
	0xdd, 0x51, 0xc8, 0x5a, 0x84, 0x85, 0xcb, 0x8b, 0x0f, 0x5b, 0xdd, 0x80, 0xd9, 0x78, 0x0d, 0xea,
	0x32, 0xfd, 0xef, 0x88, 0x2d, 0x03, 0xee, 0xa5, 0x89, 0x0d, 0x8a, 0x2d, 0x7f, 0xcb, 0x42, 0xb6,
	0x2e, 0x7c, 0xb2, 0x07, 0x24, 0xe5, 0x0d, 0xf1, 0xf0, 0x9c, 0xa3, 0x52, 0xed, 0x51, 0x5e, 0x9c,
	0x84, 0x35, 0xa8, 0x48, 0xda, 0x70, 0x2b, 0xcd, 0x40, 0xf3, 0x17, 0x45, 0x52, 0x68, 0xe5, 0xa5,
	0x89, 0x68, 0xc3, 0x62, 0x9f, 0x35, 0x30, 0x2f, 0x5b, 0xfa, 0xd3, 0x8b, 0x92, 0x97, 0xa4, 0x94,
	0x9f, 0x5f, 0x39, 0x65, 0xd8, 0x11, 0xc2, 0xcd, 0x8b, 0xab, 0x7d, 0x90, 0x32, 0xc1, 0xf3, 0xa4,
	0xf2, 0x93, 0x09, 0x48, 0x83, 0x32, 0xb5, 0xb5, 0xc3, 0x13, 0x43, 0x3b, 0x3a, 0x31, 0xb4, 0x5f,
	0x27, 0x86, 0x76, 0x70, 0x6a, 0x64, 0x8e, 0x4e, 0x8d, 0xcc, 0xf7, 0x53, 0x23, 0xf3, 0x6e, 0x61,
	0xe4, 0x72, 0x6d, 0x04, 0xdc, 0x5b, 0x65, 0x1c, 0x1d, 0x81, 0x6d, 0x2f, 0x70, 0xf6, 0x47, 0x3e,
	0x4f, 0xf1, 0x25, 0x6b, 0xe4, 0xd5, 0xbb, 0xfa, 0xd9, 0x9f, 0x00, 0x00, 0x00, 0xff, 0xff, 0xc5,
	0x74, 0xf1, 0xc5, 0xbc, 0x06, 0x00, 0x00,
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// MsgClient is the client API for Msg service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type MsgClient interface {
	// spending-pool-create- a function to allow creating a new spending pool.
	// This function can be sent by any account. The person sending the transaction automatically becomes the pool owner.
	// The original owner should provide a unique pool name when sending create tx.
	CreateSpendingPool(ctx context.Context, in *MsgCreateSpendingPool, opts ...grpc.CallOption) (*MsgCreateSpendingPoolResponse, error)
	// spending-pool-deposit - a function to allow depositing tokens to the pool address (name).
	// Any KIRA address should be able to call this function and deposit tokens.
	DepositSpendingPool(ctx context.Context, in *MsgDepositSpendingPool, opts ...grpc.CallOption) (*MsgDepositSpendingPoolResponse, error)
	// spending-pool-register - a function to register beneficiary account to be
	// eligible for claims
	RegisterSpendingPoolBeneficiary(ctx context.Context, in *MsgRegisterSpendingPoolBeneficiary, opts ...grpc.CallOption) (*MsgRegisterSpendingPoolBeneficiaryResponse, error)
	// spending-pool-claim - a function to allow claiming tokens from the pool.
	// Only beneficiaries should be able to send this transaction.
	// Funds can be claimed only for the period between current bloct time and value set in the claims property in accordance to the current distribution rate. If the pool doesn't have a sufficient balance of a specific token as defined by tokens property then that specific token should NOT be sent in any amount. If the pool has sufficient funds as defined by the amount in the tokens property then exact amount owed should be sent to the beneficiary. All tokens that can be sent should be sent all at once to the account that is claiming them. If the claim expiration period elapsed and funds were NOT claimed by the beneficiary then the funds will NOT be sent. Beneficiary will only receive tokens if he already registered and his account is present in the claims array. Claiming of specific token should be only possible if and only if the spending pool has sufficient funds to distribute funds to ALL accounts eligible for claiming them (either all eligible accounts can claim a specific token or no one).
	ClaimSpendingPool(ctx context.Context, in *MsgClaimSpendingPool, opts ...grpc.CallOption) (*MsgClaimSpendingPoolResponse, error)
}

type msgClient struct {
	cc grpc1.ClientConn
}

func NewMsgClient(cc grpc1.ClientConn) MsgClient {
	return &msgClient{cc}
}

func (c *msgClient) CreateSpendingPool(ctx context.Context, in *MsgCreateSpendingPool, opts ...grpc.CallOption) (*MsgCreateSpendingPoolResponse, error) {
	out := new(MsgCreateSpendingPoolResponse)
	err := c.cc.Invoke(ctx, "/kira.spending.Msg/CreateSpendingPool", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *msgClient) DepositSpendingPool(ctx context.Context, in *MsgDepositSpendingPool, opts ...grpc.CallOption) (*MsgDepositSpendingPoolResponse, error) {
	out := new(MsgDepositSpendingPoolResponse)
	err := c.cc.Invoke(ctx, "/kira.spending.Msg/DepositSpendingPool", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *msgClient) RegisterSpendingPoolBeneficiary(ctx context.Context, in *MsgRegisterSpendingPoolBeneficiary, opts ...grpc.CallOption) (*MsgRegisterSpendingPoolBeneficiaryResponse, error) {
	out := new(MsgRegisterSpendingPoolBeneficiaryResponse)
	err := c.cc.Invoke(ctx, "/kira.spending.Msg/RegisterSpendingPoolBeneficiary", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *msgClient) ClaimSpendingPool(ctx context.Context, in *MsgClaimSpendingPool, opts ...grpc.CallOption) (*MsgClaimSpendingPoolResponse, error) {
	out := new(MsgClaimSpendingPoolResponse)
	err := c.cc.Invoke(ctx, "/kira.spending.Msg/ClaimSpendingPool", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// MsgServer is the server API for Msg service.
type MsgServer interface {
	// spending-pool-create- a function to allow creating a new spending pool.
	// This function can be sent by any account. The person sending the transaction automatically becomes the pool owner.
	// The original owner should provide a unique pool name when sending create tx.
	CreateSpendingPool(context.Context, *MsgCreateSpendingPool) (*MsgCreateSpendingPoolResponse, error)
	// spending-pool-deposit - a function to allow depositing tokens to the pool address (name).
	// Any KIRA address should be able to call this function and deposit tokens.
	DepositSpendingPool(context.Context, *MsgDepositSpendingPool) (*MsgDepositSpendingPoolResponse, error)
	// spending-pool-register - a function to register beneficiary account to be
	// eligible for claims
	RegisterSpendingPoolBeneficiary(context.Context, *MsgRegisterSpendingPoolBeneficiary) (*MsgRegisterSpendingPoolBeneficiaryResponse, error)
	// spending-pool-claim - a function to allow claiming tokens from the pool.
	// Only beneficiaries should be able to send this transaction.
	// Funds can be claimed only for the period between current bloct time and value set in the claims property in accordance to the current distribution rate. If the pool doesn't have a sufficient balance of a specific token as defined by tokens property then that specific token should NOT be sent in any amount. If the pool has sufficient funds as defined by the amount in the tokens property then exact amount owed should be sent to the beneficiary. All tokens that can be sent should be sent all at once to the account that is claiming them. If the claim expiration period elapsed and funds were NOT claimed by the beneficiary then the funds will NOT be sent. Beneficiary will only receive tokens if he already registered and his account is present in the claims array. Claiming of specific token should be only possible if and only if the spending pool has sufficient funds to distribute funds to ALL accounts eligible for claiming them (either all eligible accounts can claim a specific token or no one).
	ClaimSpendingPool(context.Context, *MsgClaimSpendingPool) (*MsgClaimSpendingPoolResponse, error)
}

// UnimplementedMsgServer can be embedded to have forward compatible implementations.
type UnimplementedMsgServer struct {
}

func (*UnimplementedMsgServer) CreateSpendingPool(ctx context.Context, req *MsgCreateSpendingPool) (*MsgCreateSpendingPoolResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreateSpendingPool not implemented")
}
func (*UnimplementedMsgServer) DepositSpendingPool(ctx context.Context, req *MsgDepositSpendingPool) (*MsgDepositSpendingPoolResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DepositSpendingPool not implemented")
}
func (*UnimplementedMsgServer) RegisterSpendingPoolBeneficiary(ctx context.Context, req *MsgRegisterSpendingPoolBeneficiary) (*MsgRegisterSpendingPoolBeneficiaryResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RegisterSpendingPoolBeneficiary not implemented")
}
func (*UnimplementedMsgServer) ClaimSpendingPool(ctx context.Context, req *MsgClaimSpendingPool) (*MsgClaimSpendingPoolResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ClaimSpendingPool not implemented")
}

func RegisterMsgServer(s grpc1.Server, srv MsgServer) {
	s.RegisterService(&_Msg_serviceDesc, srv)
}

func _Msg_CreateSpendingPool_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MsgCreateSpendingPool)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MsgServer).CreateSpendingPool(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/kira.spending.Msg/CreateSpendingPool",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MsgServer).CreateSpendingPool(ctx, req.(*MsgCreateSpendingPool))
	}
	return interceptor(ctx, in, info, handler)
}

func _Msg_DepositSpendingPool_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MsgDepositSpendingPool)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MsgServer).DepositSpendingPool(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/kira.spending.Msg/DepositSpendingPool",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MsgServer).DepositSpendingPool(ctx, req.(*MsgDepositSpendingPool))
	}
	return interceptor(ctx, in, info, handler)
}

func _Msg_RegisterSpendingPoolBeneficiary_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MsgRegisterSpendingPoolBeneficiary)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MsgServer).RegisterSpendingPoolBeneficiary(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/kira.spending.Msg/RegisterSpendingPoolBeneficiary",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MsgServer).RegisterSpendingPoolBeneficiary(ctx, req.(*MsgRegisterSpendingPoolBeneficiary))
	}
	return interceptor(ctx, in, info, handler)
}

func _Msg_ClaimSpendingPool_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MsgClaimSpendingPool)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MsgServer).ClaimSpendingPool(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/kira.spending.Msg/ClaimSpendingPool",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MsgServer).ClaimSpendingPool(ctx, req.(*MsgClaimSpendingPool))
	}
	return interceptor(ctx, in, info, handler)
}

var _Msg_serviceDesc = grpc.ServiceDesc{
	ServiceName: "kira.spending.Msg",
	HandlerType: (*MsgServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "CreateSpendingPool",
			Handler:    _Msg_CreateSpendingPool_Handler,
		},
		{
			MethodName: "DepositSpendingPool",
			Handler:    _Msg_DepositSpendingPool_Handler,
		},
		{
			MethodName: "RegisterSpendingPoolBeneficiary",
			Handler:    _Msg_RegisterSpendingPoolBeneficiary_Handler,
		},
		{
			MethodName: "ClaimSpendingPool",
			Handler:    _Msg_ClaimSpendingPool_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "kira/spending/tx.proto",
}

func (m *MsgCreateSpendingPool) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgCreateSpendingPool) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgCreateSpendingPool) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Sender) > 0 {
		i -= len(m.Sender)
		copy(dAtA[i:], m.Sender)
		i = encodeVarintTx(dAtA, i, uint64(len(m.Sender)))
		i--
		dAtA[i] = 0x62
	}
	if m.Beneficiaries != nil {
		{
			size, err := m.Beneficiaries.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTx(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x5a
	}
	if m.Owners != nil {
		{
			size, err := m.Owners.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTx(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x52
	}
	if m.VoteEnactment != 0 {
		i = encodeVarintTx(dAtA, i, uint64(m.VoteEnactment))
		i--
		dAtA[i] = 0x48
	}
	if m.VotePeriod != 0 {
		i = encodeVarintTx(dAtA, i, uint64(m.VotePeriod))
		i--
		dAtA[i] = 0x40
	}
	if m.VoteQuorum != 0 {
		i = encodeVarintTx(dAtA, i, uint64(m.VoteQuorum))
		i--
		dAtA[i] = 0x38
	}
	{
		size := m.Rate.Size()
		i -= size
		if _, err := m.Rate.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintTx(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x32
	if len(m.Token) > 0 {
		i -= len(m.Token)
		copy(dAtA[i:], m.Token)
		i = encodeVarintTx(dAtA, i, uint64(len(m.Token)))
		i--
		dAtA[i] = 0x2a
	}
	if m.Expire != 0 {
		i = encodeVarintTx(dAtA, i, uint64(m.Expire))
		i--
		dAtA[i] = 0x20
	}
	n3, err3 := github_com_gogo_protobuf_types.StdTimeMarshalTo(m.ClaimEnd, dAtA[i-github_com_gogo_protobuf_types.SizeOfStdTime(m.ClaimEnd):])
	if err3 != nil {
		return 0, err3
	}
	i -= n3
	i = encodeVarintTx(dAtA, i, uint64(n3))
	i--
	dAtA[i] = 0x1a
	n4, err4 := github_com_gogo_protobuf_types.StdTimeMarshalTo(m.ClaimStart, dAtA[i-github_com_gogo_protobuf_types.SizeOfStdTime(m.ClaimStart):])
	if err4 != nil {
		return 0, err4
	}
	i -= n4
	i = encodeVarintTx(dAtA, i, uint64(n4))
	i--
	dAtA[i] = 0x12
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintTx(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MsgCreateSpendingPoolResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgCreateSpendingPoolResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgCreateSpendingPoolResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	return len(dAtA) - i, nil
}

func (m *MsgDepositSpendingPool) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgDepositSpendingPool) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgDepositSpendingPool) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Amount) > 0 {
		for iNdEx := len(m.Amount) - 1; iNdEx >= 0; iNdEx-- {
			{
				size := m.Amount[iNdEx].Size()
				i -= size
				if _, err := m.Amount[iNdEx].MarshalTo(dAtA[i:]); err != nil {
					return 0, err
				}
				i = encodeVarintTx(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1a
		}
	}
	if len(m.PoolName) > 0 {
		i -= len(m.PoolName)
		copy(dAtA[i:], m.PoolName)
		i = encodeVarintTx(dAtA, i, uint64(len(m.PoolName)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Sender) > 0 {
		i -= len(m.Sender)
		copy(dAtA[i:], m.Sender)
		i = encodeVarintTx(dAtA, i, uint64(len(m.Sender)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MsgDepositSpendingPoolResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgDepositSpendingPoolResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgDepositSpendingPoolResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	return len(dAtA) - i, nil
}

func (m *MsgRegisterSpendingPoolBeneficiary) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgRegisterSpendingPoolBeneficiary) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgRegisterSpendingPoolBeneficiary) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Beneficiary) > 0 {
		i -= len(m.Beneficiary)
		copy(dAtA[i:], m.Beneficiary)
		i = encodeVarintTx(dAtA, i, uint64(len(m.Beneficiary)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.PoolName) > 0 {
		i -= len(m.PoolName)
		copy(dAtA[i:], m.PoolName)
		i = encodeVarintTx(dAtA, i, uint64(len(m.PoolName)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Sender) > 0 {
		i -= len(m.Sender)
		copy(dAtA[i:], m.Sender)
		i = encodeVarintTx(dAtA, i, uint64(len(m.Sender)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MsgRegisterSpendingPoolBeneficiaryResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgRegisterSpendingPoolBeneficiaryResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgRegisterSpendingPoolBeneficiaryResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	return len(dAtA) - i, nil
}

func (m *MsgClaimSpendingPool) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgClaimSpendingPool) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgClaimSpendingPool) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.PoolName) > 0 {
		i -= len(m.PoolName)
		copy(dAtA[i:], m.PoolName)
		i = encodeVarintTx(dAtA, i, uint64(len(m.PoolName)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Sender) > 0 {
		i -= len(m.Sender)
		copy(dAtA[i:], m.Sender)
		i = encodeVarintTx(dAtA, i, uint64(len(m.Sender)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MsgClaimSpendingPoolResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgClaimSpendingPoolResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgClaimSpendingPoolResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	return len(dAtA) - i, nil
}

func encodeVarintTx(dAtA []byte, offset int, v uint64) int {
	offset -= sovTx(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *MsgCreateSpendingPool) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = github_com_gogo_protobuf_types.SizeOfStdTime(m.ClaimStart)
	n += 1 + l + sovTx(uint64(l))
	l = github_com_gogo_protobuf_types.SizeOfStdTime(m.ClaimEnd)
	n += 1 + l + sovTx(uint64(l))
	if m.Expire != 0 {
		n += 1 + sovTx(uint64(m.Expire))
	}
	l = len(m.Token)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = m.Rate.Size()
	n += 1 + l + sovTx(uint64(l))
	if m.VoteQuorum != 0 {
		n += 1 + sovTx(uint64(m.VoteQuorum))
	}
	if m.VotePeriod != 0 {
		n += 1 + sovTx(uint64(m.VotePeriod))
	}
	if m.VoteEnactment != 0 {
		n += 1 + sovTx(uint64(m.VoteEnactment))
	}
	if m.Owners != nil {
		l = m.Owners.Size()
		n += 1 + l + sovTx(uint64(l))
	}
	if m.Beneficiaries != nil {
		l = m.Beneficiaries.Size()
		n += 1 + l + sovTx(uint64(l))
	}
	l = len(m.Sender)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	return n
}

func (m *MsgCreateSpendingPoolResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	return n
}

func (m *MsgDepositSpendingPool) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Sender)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = len(m.PoolName)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	if len(m.Amount) > 0 {
		for _, e := range m.Amount {
			l = e.Size()
			n += 1 + l + sovTx(uint64(l))
		}
	}
	return n
}

func (m *MsgDepositSpendingPoolResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	return n
}

func (m *MsgRegisterSpendingPoolBeneficiary) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Sender)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = len(m.PoolName)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = len(m.Beneficiary)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	return n
}

func (m *MsgRegisterSpendingPoolBeneficiaryResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	return n
}

func (m *MsgClaimSpendingPool) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Sender)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = len(m.PoolName)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	return n
}

func (m *MsgClaimSpendingPoolResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	return n
}

func sovTx(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozTx(x uint64) (n int) {
	return sovTx(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *MsgCreateSpendingPool) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgCreateSpendingPool: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgCreateSpendingPool: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClaimStart", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := github_com_gogo_protobuf_types.StdTimeUnmarshal(&m.ClaimStart, dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClaimEnd", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := github_com_gogo_protobuf_types.StdTimeUnmarshal(&m.ClaimEnd, dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Expire", wireType)
			}
			m.Expire = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Expire |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Token", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Token = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Rate", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Rate.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field VoteQuorum", wireType)
			}
			m.VoteQuorum = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.VoteQuorum |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field VotePeriod", wireType)
			}
			m.VotePeriod = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.VotePeriod |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field VoteEnactment", wireType)
			}
			m.VoteEnactment = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.VoteEnactment |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Owners", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Owners == nil {
				m.Owners = &PermInfo{}
			}
			if err := m.Owners.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Beneficiaries", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Beneficiaries == nil {
				m.Beneficiaries = &PermInfo{}
			}
			if err := m.Beneficiaries.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sender", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Sender = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgCreateSpendingPoolResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgCreateSpendingPoolResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgCreateSpendingPoolResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgDepositSpendingPool) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgDepositSpendingPool: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgDepositSpendingPool: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sender", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Sender = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PoolName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PoolName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Amount", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			var v github_com_cosmos_cosmos_sdk_types.Coin
			m.Amount = append(m.Amount, v)
			if err := m.Amount[len(m.Amount)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgDepositSpendingPoolResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgDepositSpendingPoolResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgDepositSpendingPoolResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgRegisterSpendingPoolBeneficiary) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgRegisterSpendingPoolBeneficiary: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgRegisterSpendingPoolBeneficiary: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sender", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Sender = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PoolName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PoolName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Beneficiary", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Beneficiary = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgRegisterSpendingPoolBeneficiaryResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgRegisterSpendingPoolBeneficiaryResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgRegisterSpendingPoolBeneficiaryResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgClaimSpendingPool) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgClaimSpendingPool: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgClaimSpendingPool: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sender", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Sender = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PoolName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PoolName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgClaimSpendingPoolResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgClaimSpendingPoolResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgClaimSpendingPoolResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipTx(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowTx
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowTx
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowTx
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthTx
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupTx
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthTx
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthTx        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowTx          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupTx = fmt.Errorf("proto: unexpected end of group")
)
